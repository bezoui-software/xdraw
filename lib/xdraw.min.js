//Developed and created by Walid Bezoui
//Github: bezoui-software
//Mail: wbezoui@gmail.com

//Copyright 2020 - Walid Bezoui

//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
//3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

//BSD-3-Clause License:
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
//BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
//OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
//HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
//EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"use strict";function random(t,r){if(t instanceof Array)return randomElementFromArray(t);if(!r){const e=t;t=0,r=e}return Math.random()*(r-t)+t}function randomInt(t,r){return floor(random(--t,++r))}function randomElementFromArray(t){return t[randomInt(t.length+1)]}window&&(window.XDraw=new class{constructor(){this.throwError=((t,r)=>{throw t+" Error : "+r}),this.Canvas=class{constructor(t,r){this.width=t,this.height=r,this.elt,this.ctx,this.strokeColor,this.fillColor,this.run()}run(){this.elt=document.createElement("canvas"),this.elt.width=this.width,this.elt.height=this.height,this.ctx=this.elt.getContext("2d"),this.render(),this.setupEvents()}setupEvents(){const t=this;this.elt.addEventListener("click",r=>t.updateMousePosition(r)),this.elt.addEventListener("mousemove",r=>t.updateMousePosition(r))}updateMousePosition(t){this.mouseX=t.clientX-this.elt.offsetLeft,this.mouseY=t.clientY-this.elt.offsetTop}render(){document.body.appendChild(this.elt)}draw(){this.ctx.stroke(),this.ctx.fill()}translate(t,r){this.ctx.translate(t,r)}moveTo(t,r){this.ctx.moveTo(t,r)}lineTo(t,r){this.ctx.lineTo(t,r),this.draw()}rotate(t){this.ctx.rotate(t)}begin(){this.ctx.save()}end(){this.ctx.restore()}beginDraw(){this.ctx.beginPath(),this.moveTo(0,0)}closeDraw(){this.ctx.closePath()}fill(t,r,e,i){const o=Color(t,r,e,i);this.ctx.fillStyle=o.getRGBA()}noFill(){this.fill(0,0)}stroke(t,r,e,i){const o=Color(t,r,e,i);this.ctx.strokeStyle=o.getRGBA()}noStroke(){this.stroke(0,0)}strokeWeight(t){this.ctx.lineWidth=t}vertex(t,r){this.ctx.lineTo(t,r),this.draw()}rect(t,r,e,i){this.ctx.beginPath(),this.ctx.rect(t,r,e,i),this.draw()}ellipse(t,r,e,i=e){const o={h:e,v:i};this.ctx.beginPath(),this.ctx.ellipse(t,r,o.h,o.v,0,0,360),this.draw()}line(t,r,e,i){this.begin(),this.beginDraw(),this.moveTo(t,r),this.lineTo(e,i),this.end()}point(t,r){this.ellipse(t,r,1)}text(t,r,e){this.ctx.fillText(t,r,e),this.ctx.strokeText(t,r,e)}textAlign(t){this.ctx.textAlign=t}textSize(t){let r=this.ctx.font.split(" ");r[0]=t,this.ctx.font=r.join(" ")}textFont(t){const r=this.getTextSize();this.ctx.font=r.concat(" ",t)}getTextFont(){let t=this.ctx.font.split(" ");return(t=t.slice(1,t.length-1)).join(" ")}getTextSize(){return this.ctx.font.split(" ")[0]}clear(){this.ctx.clearRect(0,0,this.width,this.height)}background(t,r,e){this.clear();let i=Color(t,r,e);this.fill(i),this.rect(0,0,this.width,this.height)}},this.Vector=class{constructor(t=0,r=0){t instanceof XDraw.Vector?this.paste(t):this.set(t,r)}set(t,r){this.x=t,this.y=r}paste(t){this.set(t.x,t.y)}magSq(){return this.x**2+this.y**2}mag(){return sqrt(this.magSq())}div(t){t instanceof XDraw.Vector?this.divByVector(t):"number"==typeof t&&this.divByNumber(t)}divByNumber(t){if("number"!=typeof t)return this.throwError("XDraw.Vector Error: <"+t+"> isn't a valide Number");this.x/=t,this.y/=t}divByVector(t){if(!(t instanceof XDraw.Vector))return this.throwError("XDraw.Vector Error: <"+t+"> isn't a valide XDraw.Vector");this.x/=t.x,this.y/=t.y}mult(t){t instanceof XDraw.Vector?multByVector(t):"number"==typeof t&&this.multByNumber(t)}multByNumber(t){if("number"!=typeof t)return this.throwError("XDraw.Vector Error: <"+t+"> isn't a valide Number");this.x*=t,this.y*=t}multByVector(t){if(!(t instanceof XDraw.Vector))return this.throwError("XDraw.Vector Error: <"+t+"> isn't a valide XDraw.Vector");this.x*=t.x,this.y*=t.y}normalize(){this.div(this.mag())}setMag(t){this.normalize(),this.mult(t)}limit(t){return this.mag()>t&&(this.div(this.mag()),this.mult(t)),this}headingRad(){return atan(this.y/this.x)}headingDeg(){return degrees(this.headingRad())}add(t){t instanceof XDraw.Vector?this.addVector(t):"number"==typeof t&&this.addNumber(t)}addVector(t){t instanceof XDraw.Vector||XDraw.Vector.throwInvalidVectorError(t),this.x+=t.x,this.y+=t.y}addNumber(t){"number"!=typeof t&&XDraw.Vector.throwInvalidNumberError(t),this.x+=t,this.y+=t}copy(){return new XDraw.Vector(this)}throwError(t){throw Error("XDraw.Vector Error: "+t)}static throwError(t){XDraw.throwError("XDraw.Vector",t)}static throwInvalidVectorError(t){XDraw.Vector.throwError("<"+t+"> isn't a valide XDraw.Vector")}static throwInvalidNumberError(t){XDraw.Vector.throwError("<"+t+"> isn't a valide XDraw.Number")}static distSq(t,r){return(r.x-t.x)**2+(r.y-t.y)**2}static dist(t,r){return sqrt(XDraw.Vector.distSq(t,r))}static random(){return new XDraw.Vector(random(-1,1),random(-1,1))}static dotProduct(t,r){return t instanceof XDraw.Vector||XDraw.Vector.throwInvalidVectorError(t),r instanceof XDraw.Vector||XDraw.Vector.throwInvalidVectorError(r),t.x*r.x+t.y*r.y}},this.Color=class{constructor(t,r,e,i){this.values={},this.evaluate(t,r,e,i)}getRGBA(){let t,r,e,i;return t=this.values.rgba[0],r=this.values.rgba[1],e=this.values.rgba[2],i=this.values.rgba[3]/255,"rgba("+t+","+r+","+e+","+i+")"}evaluate(t,r,e,i){t instanceof XDraw.Color?this.setFromColor(t):this.setFromRGBA(t,r,e,i)}setGrayScaleAndAlpha(t,r){this.values.rgba=[t,t,t,r]}setGrayScale(t){this.values.rgba=[t,t,t,255]}setFromRGBA(t,r,e,i){void 0===i&&(i=255),void 0!==t&&void 0!==r&&void 0!==e?this.values.rgba=[t,r,e,i]:void 0!==t&&void 0!==r?this.setGrayScaleAndAlpha(t,r):void 0!==t&&this.setGrayScale(t)}setFromColor(t){let r=t.values.rgba[0],e=t.values.rgba[1],i=t.values.rgba[2];this.setFromRGBA(r,e,i)}},this.Noise=(t=>{const r=floor(t);let e=fract(t);e=e**2*(3-2*e);const i=mix(random(r),random(r+1),e);return i}),this.Noise2D=((t,r)=>{const e=createVector(floor(t),floor(r)),i=createVector(e.x+1,e.y+1),o=new Array(4);for(let t=0;t<o.length;t++){const r=choice(-1,1),e=choice(-1,1);o[t]=createVector(r,e)}const s=new Array(4);s[0]=createVector(t-e.x,r-e.y),s[1]=createVector(t-e.x,r-i.y),s[2]=createVector(t-i.x,r-e.y),s[3]=createVector(t-i.x,r-i.y);const a=new Array(4);for(let t=0;t<a.length;t++)a[t]=XDraw.Vector.dotProduct(s[t],o[t]);const h=new Array(2);return h[0]=lerp(a[0],a[1],fade(t-e.x)),h[1]=lerp(a[2],a[3],fade(t-e.x)),lerp(h[0],h[1],fade(r-e.y))})}});const createCanvas=(t,r)=>new XDraw.Canvas(t,r),createVector=(t,r)=>new XDraw.Vector(t,r),Color=(t,r,e,i)=>new XDraw.Color(t,r,e,i),floor=t=>~~t,choice=(...t)=>random(t),lerp=(t,r,e)=>(1-e)*t+e*r,fade=t=>6*t**5-15*t**4+10*t**3,fract=t=>t-floor(t),mix=(t,r,e)=>t*(1-e)+r*e,sqrt=t=>Math.sqrt(t),tan=t=>Math.tan(t),atan=t=>Math.atan(t),radians=t=>t*(Math.PI/180),degrees=t=>t*(180/Math.PI);
